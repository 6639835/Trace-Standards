Below is a clean **standards-repo structure** + **complete markdown content** you can paste in as files. It’s written to match what we discussed: **SwiftUI + MVVM + Swift 6 strict concurrency + multi-module Trace***, **swift-format + SwiftLint**, **DocC-style docs**, **XCTest-first (Swift Testing optional later)**, and a **logging standard** with levels/categories/format.

---

## Recommended repo structure

```text
trace-standards/
├─ README.md
├─ docs/
│  ├─ INDEX.md
│  ├─ swift/
│  │  ├─ 01-overview.md
│  │  ├─ 02-style-format-lint.md
│  │  ├─ 03-architecture-mvvm.md
│  │  ├─ 04-concurrency.md
│  │  ├─ 05-documentation-comments.md
│  │  ├─ 06-logging.md
│  │  ├─ 07-error-handling.md
│  │  ├─ 08-networking-streaming.md
│  │  ├─ 09-testing.md
│  │  ├─ 10-module-boundaries.md
│  │  ├─ 11-code-review.md
│  │  └─ 12-file-organization.md
│  ├─ adr/
│  │  ├─ README.md
│  │  └─ 0001-template.md
│  └─ glossary.md
├─ templates/
│  ├─ swift/
│  │  ├─ .swift-format
│  │  ├─ .swiftlint.yml
│  │  └─ CODEGEN_SYSTEM_PROMPT.md
│  └─ pull_request_template.md
└─ CHANGELOG.md
```

---

# File: `README.md`

```markdown
# Trace Standards

This repository defines the engineering standards for Trace iOS development (Swift 6, SwiftUI, MVVM, multi-module Trace* architecture, zero third-party by default).

## Goals
- Consistent, readable, maintainable Swift across modules
- Safe concurrency defaults (Swift 6 strict concurrency)
- Predictable logging and error handling
- Testable architecture (protocol-first DI)
- Enforced formatting + linting to prevent style drift

## What belongs here
- Standards and conventions (Markdown)
- Templates (SwiftLint, swift-format, PR template, codegen prompt)
- Architecture decisions (ADRs) for big changes

## How to use
1. Read `docs/INDEX.md` for the table of contents.
2. Copy templates from `templates/swift/` into the codebase.
3. Enforce rules in CI and PR review (see `docs/swift/11-code-review.md`).

## Ownership
- Tech Lead owns final decisions.
- Everyone can propose changes via PR + ADR when needed.

## Versioning
We track changes in `CHANGELOG.md`. Standards changes should be reviewed like code changes.
```

---

# File: `docs/INDEX.md`

```markdown
# Documentation Index

## Swift Standards
- [01 Overview](swift/01-overview.md)
- [02 Style, Formatting, Linting](swift/02-style-format-lint.md)
- [03 Architecture: SwiftUI + MVVM](swift/03-architecture-mvvm.md)
- [04 Concurrency (Swift 6)](swift/04-concurrency.md)
- [05 Documentation & Comments](swift/05-documentation-comments.md)
- [06 Logging](swift/06-logging.md)
- [07 Error Handling](swift/07-error-handling.md)
- [08 Networking & Streaming (SSE/WebSocket)](swift/08-networking-streaming.md)
- [09 Testing](swift/09-testing.md)
- [10 Module Boundaries & Dependencies](swift/10-module-boundaries.md)
- [11 Code Review Standards](swift/11-code-review.md)
- [12 File Organization](swift/12-file-organization.md)

## Cross-cutting
- [Glossary](glossary.md)

## ADRs (Architecture Decision Records)
- [ADR Guide](adr/README.md)
```

---

# File: `docs/swift/01-overview.md`

```markdown
# Swift Standards Overview (Trace)

## Scope
These standards apply to all iOS app targets and first-party modules:
- Foundation: `TraceCore`, `TraceCompression`
- Infrastructure: `TraceSecurity`, `TraceNetworking`
- Feature: `TraceProxy`, `TraceFeatures`, `TraceUI`
- App: `Trace`, `TraceVPN`, `TraceWidget`

## Default stack
- Swift language mode: Swift 6
- UI: SwiftUI-first
- Architecture: MVVM
- Dependencies: first-party only unless explicitly approved
- Formatting: swift-format
- Linting: SwiftLint
- Testing: XCTest (Swift Testing allowed when we start migration)

## “Must” rules (summary)
- No force unwrap (`!`), no `try!`, no empty catches
- ViewModels are `@MainActor`
- Async work is cancellable and uses structured concurrency
- Public APIs are small and documented
- Log consistently and never log secrets
- Format + lint in CI
```

---

# File: `docs/swift/02-style-format-lint.md`

```markdown
# Style, Formatting, and Linting

## Naming
We follow Swift’s API design principles:
- Prefer clarity at the call site
- Use meaningful argument labels
- Avoid abbreviations unless universally understood
- Use nouns for types, verbs for methods

## Formatting (swift-format)
- Formatting is not a debate: we format with `swift-format`.
- The repo should contain a `.swift-format` file (see `templates/swift/.swift-format`).

Rules of thumb:
- Let the formatter decide whitespace/line breaks
- Keep lines readable; avoid deeply nested closures without extracting helpers

## Linting (SwiftLint)
We lint with SwiftLint for consistency and to prevent common mistakes.
- Add `.swiftlint.yml` to the repo root (see `templates/swift/.swiftlint.yml`)
- Start with warnings, tighten over time

Required practices:
- Avoid force unwrap/force try
- Avoid IUOs except when bridging legacy APIs and explicitly justified
- Prefer `private`/`fileprivate` where appropriate
- No dead code or unused imports

## “No bikeshedding” rule
If swift-format and SwiftLint agree, we follow them. If they conflict, we update configuration.
```

---

# File: `docs/swift/03-architecture-mvvm.md`

```markdown
# Architecture: SwiftUI + MVVM

## Responsibilities

### Views (SwiftUI)
Views are responsible for:
- Rendering UI from state
- Forwarding user intent (button taps, gestures) to the ViewModel
- Local ephemeral UI state (`@State`) only

Views must NOT:
- Perform networking
- Own business logic
- Parse responses
- Implement security/crypto logic

### ViewModels
ViewModels are responsible for:
- Owning feature state
- Orchestrating async workflows
- Mapping domain models to view state
- Validation and user-facing error mapping

ViewModels must:
- Be `@MainActor` (default)
- Avoid side effects in `init`
- Support cancellation of long-running tasks

### Services / Clients
Services/clients are responsible for:
- Side effects (network, storage, crypto, streaming connections)
- Being testable via protocols
- Returning typed data/errors

### Models
Models should:
- Prefer `struct`
- Conform to `Sendable` when used across tasks
- Use `Codable` where it improves clarity (not mandatory for everything)

## Suggested feature layout
- `FeatureNameView.swift`
- `FeatureNameViewModel.swift`
- `FeatureNameModels.swift`
- `FeatureNameClient.swift` (if feature owns a small client)
- Tests in `FeatureNameTests/`

## State management pattern
Recommended:
- `struct State`
- `enum ViewEvent` (optional)
- `func onAppear() async` / `func refresh() async` / explicit actions

Rules:
- No side effects in init
- Keep state transitions explicit
- Avoid hidden global state
```

---

# File: `docs/swift/04-concurrency.md`

```markdown
# Concurrency (Swift 6)

## Principles
- Prefer structured concurrency (`async/await`, `TaskGroup`)
- Avoid GCD unless bridging legacy callbacks
- Make cancellation a first-class behavior

## ViewModels are @MainActor
- ViewModels run on the main actor to keep UI state updates safe.
- Heavy work belongs in services/clients or background tasks.

## Cancellation rules
Any long-running async operation must:
- Be cancellable (check `Task.isCancelled` / handle cancellation errors)
- Cancel previous tasks before starting a new one when appropriate
- Clean up streaming tasks on stop/deinit

## Shared mutable state
- If state is shared across tasks, isolate it in an `actor`.
- Avoid locks unless absolutely necessary.

## AsyncSequence for streams
SSE/WebSocket and similar “push” sources should expose:
- `AsyncSequence` / `AsyncThrowingStream`

Document:
- Completion conditions
- Cancellation behavior
- Retry/backoff behavior
```

---

# File: `docs/swift/05-documentation-comments.md`

````markdown
# Documentation & Comments

## Doc comments (DocC / Quick Help)
Public API must include doc comments.

### Required for:
- `public` / `open` types and members
- Cross-module APIs that other teams rely on
- Complex or subtle behavior even if internal

### Doc comment style
- Start with a one-line summary ending with a period.
- Add detail only when it adds value: invariants, edge cases, performance, concurrency expectations.
- Use sections when relevant:
  - `- Parameters:`
  - `- Returns:`
  - `- Throws:`
  - Cancellation behavior for async methods

### Example
```swift
/// Connects to the stream and yields parsed events.
/// - Parameter url: The endpoint to connect to.
/// - Returns: An async sequence of events.
/// - Throws: If the connection fails or event decoding fails.
/// - Important: Cancelling the consuming task closes the connection.
func events(url: URL) -> AsyncThrowingStream<Event, Error>
````

## Inline comments

Inline comments should explain **why**, not **what**.

* Good: tradeoffs, non-obvious constraints, workaround explanations
* Bad: narrating obvious code

## File-level comments

Optional. Use them when:

* The file contains multiple related types
* The file’s purpose isn’t obvious from the name/types

## Tags

* `// TODO(owner|ticket): ...`
* `// FIXME(ticket): ...`

No commented-out code in main branches.

````

---

# File: `docs/swift/06-logging.md`

```markdown
# Logging Standard (Trace)

## Logging goals
- Reconstruct user-visible behavior and system decisions
- Debug issues without leaking secrets
- Make logs filterable by module + category
- Control noise: avoid log spam

## Logging API
Use unified logging via `OSLog.Logger` (not `print()`).

## Ownership and placement
### Where logger definitions live
- `TraceCore` provides a small wrapper/factory to standardize subsystem/category.
- Each module defines categories for its domain.

### Where log statements go
Log:
- Feature lifecycle boundaries (start/stop/connect/disconnect)
- Significant state transitions (loading → loaded → error, retry state changes)
- Network milestones (request start/finish, stream open/close)
- Errors that affect user-visible behavior or functional correctness

Do not log:
- Secrets (tokens, credentials, raw key material)
- Tight loops / per-frame UI updates
- High-volume per-message stream logs at info/warning/error levels (debug only + rate-limited)

## Subsystem and category
### Subsystem
Use the module bundle identifier when possible.
Fallback: `Bundle.main.bundleIdentifier + "." + ModuleName`

### Category naming (recommended)
Stable and filter-friendly:
- `Networking.HTTP`
- `Networking.SSE`
- `Networking.WebSocket`
- `Security.Keychain`
- `Security.Crypto`
- `UI.Navigation`
- `Feature.<Name>`
- `ViewModel.<Name>`

## Severity policy
Use levels consistently:

- `debug`: dev diagnostics; may be noisy but avoid stream spam unless rate-limited
- `info`: expected high-level milestones useful in production diagnosis
- `warning`: unexpected but recoverable; degraded behavior possible
- `error`: operation failed; user-visible behavior likely affected
- `fault` / `critical`: invariant broken, bug, corruption risk, security boundary issue; investigate immediately

Rule of thumb:
- Expected behavior: debug/info
- Ticket-worthy issue: warning/error
- “This should never happen”: fault/critical

## Privacy & sensitive data (mandatory)
- Treat user data as private by default.
- Mark interpolated values as `.private` unless explicitly safe.
- For identifiers you need to correlate without exposing, use hashed masking.

Examples:
- URL query parameters: private (hash mask or redact)
- User ID: private(hash)
- Error codes / enum cases: often public (if not sensitive)

## Message format (standard)
Console already shows timestamp/process/subsystem/category, so message content should be structured.

Required template:
`event=<domain.action> outcome=<success|failure> [duration_ms=] [id=] [reason=] [error=]`

Rules:
- `event` is mandatory and stable
- keys are `lower_snake_case`
- values are short; prefer codes/enums over long prose
- avoid embedding full JSON payloads

Examples:
- `event=networking.sse_connect outcome=success duration_ms=142`
- `event=feature.capture_start outcome=failure reason=permission_denied`

## Noise control
- Rate-limit repeated warnings/errors in reconnect loops
- For streams: per-message logs are debug-only and should be guarded by a debug flag

## Recommended implementation pattern
In `TraceCore`:
- `TraceLog.make(subsystem:category:) -> Logger`
In each module:
- define an enum of module loggers, one per category
````

---

# File: `docs/swift/07-error-handling.md`

```markdown
# Error Handling Standard

## Principles
- Use typed errors in domain layers
- Don’t swallow errors
- Don’t push raw errors directly to UI
- Make recovery paths explicit (retry/backoff, user actions)

## Typed errors
Prefer:
- `enum FeatureError: Error { ... }`
- `enum NetworkingError: Error { ... }`

Avoid:
- throwing `Error` everywhere without structure

## UI error mapping
ViewModels should map errors to user-facing state:
- `UserFacingError { message, recoverySuggestion, debugCode? }`
- Keep debug detail behind a debug-only toggle if needed.

## Logging
- Log errors at `error` if user-visible behavior changes
- Log at `warning` if recoverable with retry/degraded mode
- Use `fault/critical` for invariants and security boundary issues

## “No empty catch” rule
Every catch must:
- handle recovery OR
- log + surface a user-facing state OR
- rethrow
```

---

# File: `docs/swift/08-networking-streaming.md`

```markdown
# Networking & Streaming (HTTP, SSE, WebSocket)

## General networking rules
- Keep networking in `TraceNetworking`
- Prefer typed request/response models
- Avoid leaking transport details into ViewModels
- Never log secrets or raw sensitive payloads

## HTTP
Recommended shape:
- Endpoint/request types as value types
- Decode into typed responses
- Centralize request building (headers, auth) inside networking module

Log milestones:
- request start (info/debug)
- request success with duration (info)
- request failure with reason (warning/error)

## Streaming: SSE/WebSocket
### API shape
Expose streams as:
- `AsyncSequence` / `AsyncThrowingStream<Event, Error>`

### Required documentation
Document:
- When it completes
- Cancellation behavior (what cancels, how to close connection)
- Reconnect behavior (yes/no, backoff, max attempts)
- Threading expectations (usually not main; ViewModel publishes on main)

### Logging
Info-level:
- connect/disconnect
- reconnect scheduled
- final exhaustion/failure
Debug-level:
- event counts / summary info
Per-message logs:
- debug-only + rate-limited (off by default in production)

### Backoff
If reconnect exists, standardize:
- exponential backoff with jitter
- max retries or max total time
- emit a state transition visible to UI if it impacts functionality
```

---

# File: `docs/swift/09-testing.md`

```markdown
# Testing Standard

## Default framework
- XCTest is the default (existing codebase standard).
- Swift Testing can be adopted when we explicitly start migration.

## What we test
- ViewModels: state transitions, error mapping, cancellation
- Clients: decoding/parsing, retry/backoff policies
- Security boundaries: keychain wrappers, crypto boundaries (use test vectors if applicable)

## Test structure guidelines
- Prefer given/when/then naming and arrangement
- Keep tests focused and fast
- Use mocks/fakes via protocol-based DI

## Coverage expectations
- Non-trivial logic requires tests
- Bug fixes should come with regression tests when feasible

## SwiftUI views
- Prefer ViewModel tests over heavy UI tests
- Add UI tests only for critical end-to-end flows when justified
```

---

# File: `docs/swift/10-module-boundaries.md`

```markdown
# Module Boundaries & Dependencies

## Goal
Prevent architecture drift and dependency cycles.

## Recommended dependency direction
- `TraceCore` depends on nothing (or only Apple frameworks)
- `TraceNetworking`, `TraceSecurity`, `TraceCompression` may depend on `TraceCore`
- `TraceUI` may depend on `TraceCore`
- `TraceFeatures` may depend on `TraceUI`, `TraceNetworking`, `TraceSecurity`, `TraceCore`
- App targets may depend on everything

## Rules
- Avoid “reverse imports” (e.g., `TraceCore` importing `TraceFeatures`)
- Keep public API minimal and documented
- Prefer composition over cross-module reach-through

## Enforcement (recommended)
- Document allowed imports
- Add a simple CI script to detect forbidden imports (regex/grep is sufficient)
```

---

# File: `docs/swift/11-code-review.md`

```markdown
# Code Review Standard

## PR checklist (required)
- [ ] swift-format applied / passes formatting check
- [ ] SwiftLint passes (or warnings justified)
- [ ] Tests added/updated for non-trivial logic
- [ ] Public APIs documented (doc comments)
- [ ] Concurrency/cancellation considered (no leaks, safe actor usage)
- [ ] Module boundaries respected (no forbidden imports)
- [ ] Logging follows standard (levels, privacy, format)
- [ ] User-facing strings localized + accessibility labels where needed

## Review focus areas
- Correctness and safety (concurrency, cancellation)
- API clarity and naming
- Separation of responsibilities (View vs ViewModel vs Client)
- Error handling and user-facing messaging
- Logging privacy (no secrets)

## “Blocker” conditions
- Force unwrap/try without strong justification
- Empty catches or swallowed errors
- Side effects in View bodies or View init
- Logging secrets or sensitive payloads
- Introducing dependency cycles
```

---

# File: `docs/swift/12-file-organization.md`

```markdown
# File Organization

## Naming
- One primary type per file
- Filename matches the primary type: `CaptureViewModel.swift`
- Extensions live in `TypeName+Topic.swift` (e.g., `URLRequest+Trace.swift`)

## File order
1. Imports
2. Primary type
3. Private helpers
4. Extensions

## Folder conventions
- `Views/`
- `ViewModels/`
- `Models/`
- `Clients/` or `Services/`
- `Support/` (helpers that are not domain models)

## Imports
- Prefer explicit imports
- Don’t import a large feature module if a smaller foundational module is enough
```

---

# File: `docs/adr/README.md`

```markdown
# ADRs (Architecture Decision Records)

Use ADRs for decisions that affect:
- module boundaries
- concurrency model changes
- logging policy changes
- large dependency/tooling changes
- major architectural patterns

## Workflow
1. Create a new ADR file: `docs/adr/NNNN-title.md`
2. Use the template in `0001-template.md`
3. Link it in the ADR index (optional)
```

---

# File: `docs/adr/0001-template.md`

```markdown
# NNNN - Title

## Status
Proposed | Accepted | Deprecated

## Context
What problem are we solving? What constraints exist?

## Decision
What did we decide?

## Consequences
Pros, cons, tradeoffs, risks, follow-ups.

## Alternatives Considered
What else did we consider and why not?
```

---

# File: `docs/glossary.md`

```markdown
# Glossary

- **MVVM**: Model-View-ViewModel.
- **Actor**: Swift concurrency primitive that isolates mutable state.
- **AsyncSequence**: Async iteration protocol used for streaming events.
- **Subsystem/Category**: Logging metadata used to filter and organize logs in Console.
- **DocC**: Apple documentation tooling for Swift APIs and guides.
```

---

# File: `templates/swift/.swift-format`

```json
{
  "version": 1,
  "lineLength": 120,
  "indentation": { "spaces": 2 },
  "tabWidth": 2,
  "respectsExistingLineBreaks": true,
  "maximumBlankLines": 1
}
```

---

# File: `templates/swift/.swiftlint.yml`

```yaml
disabled_rules:
  - trailing_whitespace
  - line_length

opt_in_rules:
  - explicit_init
  - first_where
  - redundant_self
  - strict_fileprivate
  - unneeded_parentheses_in_closure_argument
  - unused_import
  - yoda_condition

analyzer_rules:
  - unused_declaration
  - unused_import

force_cast: warning
force_try: warning

identifier_name:
  min_length: 2
  excluded:
    - id
    - vm

type_name:
  min_length: 3
  max_length:
    warning: 50
    error: 60
```

---

# File: `templates/swift/CODEGEN_SYSTEM_PROMPT.md`

````markdown
# Codegen System Prompt (Trace Swift Standard)

Paste this as a system prompt for code generation.

```text
You are a senior Swift engineer working in a multi-module SwiftUI iOS app (Trace*, Swift 6 strict concurrency, MVVM, no third-party dependencies).

MANDATORY STANDARDS
- Naming and API shape must follow Swift API design principles: clarity at point of use, meaningful argument labels.
- Formatting: write formatter-friendly Swift intended for swift-format.
- Lint: compatible with SwiftLint conventions: avoid force unwrap/try, avoid IUOs, avoid unused imports, avoid empty catches.

ARCHITECTURE
- SwiftUI + MVVM.
- View: UI only. No business logic. No network calls.
- ViewModel: state + async actions + validation. ViewModels are @MainActor.
- Services/Clients: side effects (network, persistence, security). Inject via protocols.
- Models: prefer struct; conform to Sendable when crossing concurrency boundaries.

CONCURRENCY
- Prefer async/await, Task, TaskGroup, actors. Avoid GCD except for legacy bridging.
- All long-running async work must be cancellable.
- Streaming (SSE/WebSocket): prefer AsyncSequence/AsyncThrowingStream and document cancellation + reconnection.

ERROR HANDLING
- Typed errors. Never swallow errors.
- Map errors to user-facing state/messages via a small mapper.

LOGGING
- Use unified logging (Logger). Never use print() for product logging.
- Use subsystem/category per module.
- Levels: debug/info/warning/error/fault/critical per standard meanings.
- Format: event=<domain.action> outcome=<success|failure> key=value...
- Never log secrets; treat user data as private by default.

DOCUMENTATION
- Public APIs must have doc comments.
- Inline comments explain WHY, not WHAT.
- Use // MARK: - sections.

DELIVERABLES
- Output only what’s needed: code blocks and brief essential notes.
- Label multiple files with // File: ...
- Include minimal usage and at least one test for non-trivial logic.
````

````

---

# File: `templates/pull_request_template.md`

```markdown
## Summary
What does this PR change?

## Checklist
- [ ] swift-format applied / passes formatting check
- [ ] SwiftLint passes (or warnings justified)
- [ ] Tests added/updated for non-trivial logic
- [ ] Public APIs documented (doc comments)
- [ ] Concurrency/cancellation considered
- [ ] Module boundaries respected
- [ ] Logging follows standard (levels, privacy, format)
- [ ] Localization & accessibility considered where applicable

## Notes for reviewers
Anything risky or worth double-checking?
````

---

# File: `CHANGELOG.md`

```markdown
# Changelog

## Unreleased
- Initial standards set: SwiftUI + MVVM + Swift 6, tooling, docs, logging, testing, module boundaries.

## 1.0.0
- TBD
```

---

## If you want, I can tailor two parts with 2 quick details

1. What is your **subsystem naming** preference (bundle IDs exactly, or `com.company.trace.<module>`)?
2. Do you want **debug logs compiled out** in Release (strict), or keep them but rely on filtering?

If you reply, I’ll update `docs/swift/06-logging.md` to match your exact production policy and give a “default category list” per Trace module.
